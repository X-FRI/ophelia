use crate::ast::*;

grammar;

match {
  r"\s*" => {},
  r"#[^\n\r]*[\n\r]*" => {},
  _
}

pub Program: Program = <items: (GlobalItem)*> => Program { <> };

GlobalItem: GlobalItem = {
  DefineFun => GlobalItem::DefineFun(<>),
}

DefineFun: DefineFun = {
  <start:@L>
    "let" <ident: Ident> "(" ")" "=>" <typ: FunType> <body: Block>
  <end:@R> =>
    DefineFun { 
      pos : Position {start, end},
      ident, typ, body
    }
}

FunType: FunType = {
  <start:@L>
    <typ: FunTypeRule>
  <end:@R> =>
    FunType {
      pos : Position {start, end},
      typ
    }
}
FunTypeRule: Type = "Int" => Type::Int;

Block: Block = {
  <start:@L>
    "{" <items: (BlockItem)*> "}"
  <end:@R> =>
    Block {
      pos : Position {start, end},
      items
    }
}

BlockItem: BlockItem = {
  Stmt => BlockItem::Stmt(<>),
}

Stmt: Stmt = {
  Return => <>
}

Return: Stmt = {
  <start:@L>
    "return" <expr: IntConst> ";"
  <end:@R> => 
    Stmt::Return(Return {
      pos : Position {start, end},
      expr
    })
}

Ident: Ident = {
  <start:@L>
    <name: IdentRule>
  <end:@R> => 
    Ident {
      pos: Position {start, end},
      name
    }
}
IdentRule: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

IntConst: i32 = {
  r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}