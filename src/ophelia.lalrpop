use crate::ast::*;

grammar;

match {
  r"\s*" => {},
  r"#[^\n\r]*[\n\r]*" => {},
  _
}

pub CompUnit: CompUnit = {
  <start:@L>
    <items: (GlobalItem)*>
  <end:@R> => {
    CompUnit {
      items,
      pos: Position(start, end)
    }
  }
}

GlobalItem: GlobalItem = {
  Decl => GlobalItem::Decl(<>),
  FuncDef => GlobalItem::FuncDef(<>),
}

Decl: Decl = {
  ConstDecl => Decl::Const(<>),
  VarDecl => Decl::Var(<>),
}

ConstDecl: ConstDecl = {
  "val"
  <start:@L>
    <def: ConstDef>
    <mut defs: ("," <ConstDef>)*>
    ";"
  <end:@R> => {
    defs.insert(0, def);
    ConstDecl {
      defs,
      pos: Position(start, end)
    }
  }
}

ConstDef: ConstDef = {
  <start:@L>
    <id: Ident>
    <dims: ("[" <ConstExp> "]")*>
    "="
    <init: ConstInitVal>
  <end:@R> => {
    ConstDef { 
      id,
      dims,
      init,
      pos: Position(start, end)
    }
  }
}

ConstInitVal: ConstInitVal = {
  ConstExp => ConstInitVal::Exp(<>),
  "{" "}" => ConstInitVal::List(Vec::new()),
  "{" <init: ConstInitVal> <mut inits: ("," <ConstInitVal>)*> "}" => {
    inits.insert(0, init);
    ConstInitVal::List(inits)
  }
}

VarDecl: VarDecl = {
  <start:@L>
    "let"
    <def: VarDef>
    <mut defs: ("," <VarDef>)*>
    ";"
  <end:@R> => {
    defs.insert(0, def);
    VarDecl {
      defs,
      pos: Position(start, end)
    }
  }
}

VarDef: VarDef = {
  <start:@L>
    <id: Ident>
    <dims: ("[" <ConstExp> "]")*>
    <init: ("=" <InitVal>)?> 
  <end:@R> => {
    VarDef {
      id,
      dims,
      init,
      pos: Position(start, end) 
    }
  }
}

InitVal: InitVal = {
  Exp => InitVal::Exp(<>),
  "{" "}" => InitVal::List(Vec::new()),
  "{" <init: InitVal> <mut inits: ("," <InitVal>)*> "}" => {
    inits.insert(0, init);
    InitVal::List(inits)
  }
}

FuncDef: FuncDef = {
  <start:@L>
    <head: FuncDefHead>
    ")"
    <block: Block>
  <end:@R> => {
    FuncDef {
      ty: head.0,
      id: head.1,
      params: Vec::new(),
      block,
      pos: Position(start, end)
    }
  },

  <start:@L>
    <head: FuncDefHead>
    <param: FuncFParam>
    <mut params: ("," <FuncFParam>)*>
    ")"
    <block: Block>
  <end:@R> => {
    params.insert(0, param);
    FuncDef {
      ty: head.0,
      id: head.1,
      params,
      block,
      pos: Position(start, end)
    }
  }
}

FuncDefHead: (Type, Ident) = {
  <typ: Type> <id: Ident> "(" => (typ, id),
}

Type: Type = {
  <start:@L> "Int" <end:@R> => Type::Int(Position(start, end)),
  <start:@L> "Unit" <end:@R> => Type::Unit(Position(start, end))
}

FuncFParam: FuncFParam = {
  <start:@L>
    <typ: Type>
    <id: Ident>
    <dims: ("[" "]" <("[" <ConstExp> "]")*>)?>
  <end:@R> => {
    FuncFParam {
      typ,
      id,
      dims,
      pos :Position(start, end)
    }
  }
}

Block: Block = {
  <start:@L>
    "{"
    <items: (BlockItem)*>
    "}"
  <end:@R> =>  {
    Block {
      items,
      pos :Position(start, end)
    }
  }
}

BlockItem: BlockItem = {
  Decl => BlockItem::Decl(<>),
  Stmt => BlockItem::Stmt(<>),
}

Stmt: Stmt = {
  MatchedStmt => <>,
  OpenStmt => <>,
}

MatchedStmt: Stmt = {
  <start:@L>
    <lval: LVal>
    "="
    <exp: Exp>
    ";"
  <end:@R> => {
    Stmt::Assign(Assign {
      lval,
      exp,
      pos :Position(start, end)
    })
  },

  <start:@L>
    <exp: (Exp)?>
    ";"
  <end:@R> => {
    Stmt::ExpStmt(ExpStmt {
      exp,
      pos :Position(start, end)
    })
  },

  Block => Stmt::Block(<>),
  
  <start:@L>
    "if"
    "("
    <cond: Exp>
    ")"
    <then: MatchedStmt>
    "else"
    <else_then: MatchedStmt>
  <end:@R> => {
    Stmt::If(Box::new(If {
      cond,
      then,
      else_then: Some(else_then),
      pos :Position(start, end)
    }))
  },

  <start:@L>
    "while"
    "("
    <cond: Exp>
    ")"
    <body: MatchedStmt>
  <end:@R> => {
    Stmt::While(Box::new(While {
      cond,
      body,
      pos :Position(start, end)
    }))
  },

  <start:@L>
    "break"
    ";"
  <end:@R> => {
    Stmt::Break(Break{
      pos: Position(start, end)
    })
  },

  <start:@L>
    "continue"
    ";"
  <end:@R> => {
    Stmt::Continue(Continue{
      pos: Position(start, end)
    })
  },

  <start:@L>
    "return"
    <exp: (Exp)?>
    ";"
  <end:@R> => {
    Stmt::Return(Return {
      exp,
      pos: Position(start, end) })
  }
}

OpenStmt: Stmt = {
  <start:@L>
    "if"
    "("
    <cond: Exp>
    ")"
    <then: Stmt>
  <end:@R> => {
    Stmt::If(Box::new(If {
      cond,
      then,
      else_then: None,
      pos: Position(start, end)
    }))
  },

  <start:@L>
    "if"
    "("
    <cond: Exp>
    ")"
    <then: MatchedStmt>
    "else"
    <else_then: OpenStmt>
  <end:@R> => {
    Stmt::If(Box::new(If {
      cond,
      then,
      else_then: Some(else_then),
      pos :Position(start, end)
    }))
  },

  <start:@L>
    "while"
    "("
    <cond: Exp>
    ")"
    <body: OpenStmt>
  <end:@R> => {
    Stmt::While(Box::new(While {
      cond,
      body,
      pos: Position(start, end)
    }))
  },
}

Exp: Exp = {
  <start:@L>
    <lor: LOrExp>
  <end:@R> => {
    Exp {
      lor,
      pos: Position(start, end)
    }
  }
}

LVal: LVal = {
  <start:@L>
    <id: Ident>
    <indices: ("[" <Exp> "]")*>
  <end:@R> => {
    LVal {
      id,
      indices,
      pos: Position(start, end)
    }
  }
}

PrimaryExp: PrimaryExp = {
  "(" <Exp> ")" => PrimaryExp::Exp(Box::new(<>)),
  LVal => PrimaryExp::LVal(<>),
  Number => PrimaryExp::Number(<>),
}

UnaryExp: UnaryExp = {
  PrimaryExp => UnaryExp::Primary(<>),
  
  <start:@L>
    <id: Ident>
    "("
    ")"
  <end:@R> => {
    UnaryExp::Call(FuncCall {
      id,
      args: Vec::new(),
      pos: Position(start, end)
    })
  },

  <start:@L>
    <id: Ident>
    "("
    <arg: Exp>
    <mut args: ("," <Exp>)*>
    ")"
  <end:@R> => {
    args.insert(0, arg);
    UnaryExp::Call(FuncCall {
      id,
      args,
      pos: Position(start, end)
    })
  },

  "+" <UnaryExp> => <>,
  <op: UnaryOp> <exp: UnaryExp> => UnaryExp::Unary(op, Box::new(exp)),
}

MulExp: MulExp = {
  UnaryExp => MulExp::Unary(<>),
  <lhs: MulExp> <op: MulOp> <rhs: UnaryExp> => {
    MulExp::MulUnary(Box::new(lhs), op, rhs)
  }
}

AddExp: AddExp = {
  MulExp => AddExp::Mul(<>),
  <lhs: AddExp> <op: AddOp> <rhs: MulExp> => {
    AddExp::AddMul(Box::new(lhs), op, rhs)
  }
}

RelExp: RelExp = {
  AddExp => RelExp::Add(<>),
  <lhs: RelExp> <op: RelOp> <rhs: AddExp> => {
    RelExp::RelAdd(Box::new(lhs), op, rhs)
  }
}

EqExp: EqExp = {
  RelExp => EqExp::Rel(<>),
  <lhs: EqExp> <op: EqOp> <rhs: RelExp> => {
    EqExp::EqRel(Box::new(lhs), op, rhs)
  }
}

LAndExp: LAndExp = {
  EqExp => LAndExp::Eq(<>),
  <lhs: LAndExp> "&&" <rhs: EqExp> => {
    LAndExp::LAndEq(Box::new(lhs), rhs)
  }
}

LOrExp: LOrExp = {
  LAndExp => LOrExp::LAnd(<>),
  <lhs: LOrExp> "||" <rhs: LAndExp> => {
    LOrExp::LOrLAnd(Box::new(lhs), rhs)
  }
}

ConstExp: ConstExp = {
  <start:@L>
    <exp: Exp>
  <end:@R> => {
    ConstExp {
      exp,
      pos: Position(start, end)
    }
  }
}

Ident: Ident = {
  <start:@L>
    <id: r"[_a-zA-Z][_a-zA-Z0-9]*">
  <end:@R> => {
    Ident {
      id: id.to_string(),
      pos: Position(start, end)
    }
  }
}

Number: Number = {
  <start:@L> 
    <literal: r"[1-9][0-9]*">
  <end:@R> => {
    Number {
      value: i32::from_str_radix(literal, 10).unwrap(),
      pos: Position(start, end)
    }
  },

  <start:@L> 
    <literal: r"0[0-7]*">
  <end:@R> => {
    Number {
      value: i32::from_str_radix(literal, 8).unwrap(),
      pos: Position(start, end)
    }
  },

  <start:@L> 
    <literal: r"0[xX][0-9a-fA-F]+">
  <end:@R> => {
    Number {
      value: i32::from_str_radix(&literal[2..], 16).unwrap(),
      pos: Position(start, end)
    }
  }
}

UnaryOp: UnaryOp = {
  <start:@L>
    "-"
  <end:@R> => {
    UnaryOp::Neg(Position(start, end))
  },

  <start:@L>
    "!"
  <end:@R> => {
    UnaryOp::LNot(Position(start, end))
  }
}

MulOp: MulOp = {
  <start:@L>
    "*"
  <end:@R> => {
    MulOp::Mul(Position(start, end))
  },

  <start:@L>
    "/"
  <end:@R> => {
    MulOp::Div(Position(start, end))
  },

  <start:@L>
    "%"
  <end:@R> => {
    MulOp::Mod(Position(start, end))
  }
}

AddOp: AddOp = {
  <start:@L>
    "+"
  <end:@R> => {
    AddOp::Add(Position(start, end))
  },

  <start:@L>
    "-"
  <end:@R> => {
    AddOp::Sub(Position(start, end))
  }
}

RelOp: RelOp = {
  <start:@L>
    "<"
  <end:@R> => {
    RelOp::Lt(Position(start, end))
  },

  <start:@L>
    ">"
  <end:@R> => {
    RelOp::Gt(Position(start, end))
  },

  <start:@L>
    "<="
  <end:@R> => {
     RelOp::Le(Position(start, end))
  },

  <start:@L>
    ">="
  <end:@R> => {
     RelOp::Ge(Position(start, end))
  }
}

EqOp: EqOp = {
  <start:@L>
    "=="
  <end:@R> => {
     EqOp::Eq(Position(start, end))
  },

  <start:@L>
    "!="
  <end:@R> => {
     EqOp::Ne(Position(start, end))
  }
}
